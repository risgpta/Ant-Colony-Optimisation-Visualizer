{"version":3,"sources":["utilities/getDistance.js","App.js","reportWebVitals.js","index.js"],"names":["distBtwPoints","points","i","j","Math","sqrt","pow","x","y","App","useState","speed","canvasRef","useRef","setPoints","pointsPhermone","setPointsPhermone","antFlag","setAntFlag","ants","Map","antDescrip","setAntDescrip","ite","setIte","COLOR","setCOLOR","setShow","ALPHA","setALPHA","BETA","setBETA","EVAPORAION_RATE","setEVAPORAION_RATE","CITY_COLOR","CITY_TEXT_STYLE","PHERMONE_UNIT","parseFloat","testPath","flag","order","tx","setTimeout","createLine","length","clearLine","movePointA2B","dist","p1","p2","angle","atan2","dy","sin","dx","cos","x1","y1","x2","y2","distt","t","current","getContext","fillRect","round","clearRect","cRef","fillStyle","font","fillText","color","mx","max","globalAlpha","heuristic","p","cities","antindex","chooseFromcities","new_city","set","probability","totalProb","key","city","firstFactor","secondFactor","val","push","get","parseInt","random","cumuProb","approxRandomSelectedCity","startACO","cityArr","distanceCovered","next","console","log","temp","phermone2D","temp_antDescrip","info","className","style","margin","fontSize","fontWeight","window","innerWidth","display","justifyContent","onClick","temp2","highestTimeoutId","clearTimeout","floor","toString","ACO","type","value","onChange","e","target","min","index","mn","plotMin","plotMax","ref","width","height","innerHeight","border","backgroundColor","event","nativeEvent","offsetX","offsetY","touches","antCities","tempPhermone","tempPhermoneArr","plotCityandInit","map","ant","c","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.96370b96.chunk.js","sourcesContent":["const distBtwPoints = (points, i, j) => {\n  return Math.sqrt(\n    Math.pow(points[j].x - points[i].x, 2) +\n      Math.pow(points[j].y - points[i].y, 2)\n  );\n};\n\nexport default distBtwPoints;\n","import \"./App.css\";\nimport React, { useState, useRef, useEffect } from \"react\";\nimport distBtwPoints from \"./utilities/getDistance\";\nimport getNextPermutation from \"./utilities/getNextPermutation\";\nimport Game from \"./game\";\n\nfunction App() {\n  const [speed, setSpeed] = useState(1);\n  const canvasRef = useRef(null);\n\n  const [points, setPoints] = useState([]);\n  const [pointsPhermone, setPointsPhermone] = useState([]);\n  const [antFlag, setAntFlag] = useState([]);\n  const [initialPoint, setInitialPoint] = useState(0);\n  const [ants, setAnts] = useState(10);\n  const [maxOp, setMaxOp] = useState(0.1);\n  const [antDescrip, setAntDescrip] = useState(new Map());\n  const [ite, setIte] = useState(0);\n  const [COLOR, setCOLOR] = useState(null);\n  const [show, setShow] = useState(false);\n  const [ALPHA, setALPHA] = useState(2);\n  const [BETA, setBETA] = useState(3);\n  const [EVAPORAION_RATE, setEVAPORAION_RATE] = useState(0.5);\n\n  const evap = () => {\n    //console.log(\"antDescrip\");\n    setAntDescrip(new Map());\n    let cRef = canvasRef.current.getContext(\"2d\");\n    cRef.clearRect(0, 0, 1000, 1000);\n    for (let i = 0; i < points.length; i++) {\n      for (let j = i + 1; j < points.length; j++) {\n        createLine(points[i], points[j], \"black\", i, j);\n      }\n    }\n  };\n\n  const CITY_COLOR = \"#99ccff\";\n  const PHERMONE_COLOR = \"#99ccff\";\n  const CITY_TEXT_STYLE = \"10px Arial\";\n  const JUMP = 1;\n  const PHERMONE_UNIT = parseFloat(1 / ants);\n  const ITERATION = 1;\n\n  const plotMin = () => {\n    if ([...antDescrip].length === 0) return;\n\n    let highestTimeoutId = setTimeout(\";\"); // to stop all setTimeouts!\n    for (let i = 0; i < highestTimeoutId; i++) {\n      clearTimeout(i);\n    }\n    if (antDescrip.length === 0) return;\n    let mn = Math.min();\n    let index;\n    for (let [key, value] of antDescrip) {\n      if (value[2] < mn) {\n        mn = value[2];\n        index = key;\n      }\n    }\n    setShow(true);\n    testPath(\"green\", antDescrip.get(index)[1]);\n  };\n\n  const plotMax = () => {\n    if ([...antDescrip].length === 0) return;\n\n    let highestTimeoutId = setTimeout(\";\"); // to stop all setTimeouts!\n    for (let i = 0; i < highestTimeoutId; i++) {\n      clearTimeout(i);\n    }\n    if (antDescrip.length === 0) return;\n    let mn = Math.max();\n    let index;\n    for (let [key, value] of antDescrip) {\n      if (value[2] > mn) {\n        mn = value[2];\n        index = key;\n      }\n    }\n    setShow(true);\n    testPath(\"red\", antDescrip.get(index)[1]);\n  };\n\n  //Plot points on canvas and does initialisation: makes points array[] and antFlag array[][]\n  const plotCityandInit = (event) => {\n    console.log(event);\n    let x = event.nativeEvent.offsetX;\n    let y = event.nativeEvent.offsetY;\n\n    if (event.type === \"touchmove\") {\n      console.log(event);\n      x = event.nativeEvent.touches[0].offsetX;\n      y = event.nativeEvent.touches[0].offsetX;\n    }\n    let cRef = canvasRef.current.getContext(\"2d\");\n    cRef.fillStyle = CITY_COLOR;\n    //cRef.fillRect(x, y, 5, 5);\n    cRef.font = CITY_TEXT_STYLE;\n    //if (points.length % 2) cRef.fillText(points.length + \"🌳\", x - 1, y - 1);\n    //else cRef.fillText(points.length + \"🌴\", x - 1, y - 1);\n\n    cRef.fillText(points.length + \"⛺️\", x - 1, y - 1);\n    let temp = points;\n    temp.push({ x: x, y: y });\n    setPoints(temp);\n    let antCities = [];\n    for (let i = 0; i < ants; i++) {\n      antCities.push(false);\n    }\n    setAntFlag([...antFlag, antCities]);\n    let tempPhermone = [...pointsPhermone];\n    for (let i = 0; i < pointsPhermone.length; i++) {\n      tempPhermone[i].push(0.05);\n    }\n    let tempPhermoneArr = [];\n    for (let i = 0; i <= pointsPhermone.length; i++) {\n      tempPhermoneArr.push(0.05);\n    }\n    tempPhermone.push(tempPhermoneArr);\n    setPointsPhermone(tempPhermone);\n  };\n\n  //Makes path from p[0] to p[p.length-1] (lines)\n  const testPath = (flag, order) => {\n    let tx = 0;\n    for (let i = 1; i <= order.length; i++) {\n      // eslint-disable-next-line no-loop-func\n      setTimeout(() => {\n        if (flag === \"red\" || flag === \"green\" || flag === 1) {\n          createLine(\n            points[order[i - 1]],\n            points[order[i % order.length]],\n            flag\n          );\n        } else if (flag === 5) {\n          createLine(points[i - 1], points[i % points.length], \"\");\n        } else if (flag === 2) {\n          clearLine(points[i - 1], points[i % points.length]);\n        } else {\n          movePointA2B(points[i - 1], points[i % points.length]);\n        }\n      }, tx);\n      let dist;\n\n      if (flag === 1 || flag === 99 || flag === \"red\" || flag === \"green\") {\n        dist =\n          Math.pow(\n            points[order[i % order.length]].x - points[order[i - 1]].x,\n            2\n          ) +\n          Math.pow(\n            points[order[i % order.length]].y - points[order[i - 1]].y,\n            2\n          );\n      } else {\n        dist =\n          Math.pow(points[i % points.length].x - points[i - 1].x, 2) +\n          Math.pow(points[i % points.length].y - points[i - 1].y, 2);\n      }\n      if (flag === 1) {\n        tx += (Math.sqrt(dist) / JUMP) * speed;\n      } else if (flag === 2) {\n        tx += (Math.sqrt(dist) / JUMP) * speed;\n      } else {\n        tx += Math.sqrt(dist) * speed;\n      }\n    }\n  };\n\n  //Moves point A to B\n  const movePointA2B = (p1, p2) => {\n    let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n    let dist = 1;\n    let dy = Math.sin(angle) * dist;\n    let dx = Math.cos(angle) * dist;\n    let x1 = p1.x;\n    let y1 = p1.y;\n    let x2 = p2.x;\n    let y2 = p2.y;\n    let distt = Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));\n    for (let t = 0; t <= distt; t++) {\n      // eslint-disable-next-line no-loop-func\n      setTimeout(() => {\n        //canvasRef.current.getContext(\"2d\").fillRect(x1, y1, 1, 1);\n        canvasRef.current\n          .getContext(\"2d\")\n          .fillRect(Math.round(x1), Math.round(y1), 5, 5);\n        canvasRef.current\n          .getContext(\"2d\")\n          .clearRect(Math.round(x1 - dx), Math.round(y1 - dy), 5, 5);\n        for (let i = 0; i < points.length; i++) {\n          let x = points[i].x;\n          let y = points[i].y;\n          let cRef = canvasRef.current.getContext(\"2d\");\n          cRef.fillStyle = CITY_COLOR;\n          cRef.fillRect(x, y, 5, 5);\n          cRef.font = CITY_TEXT_STYLE;\n          if (i % 2) cRef.fillText(i + \"🌳\", x - 1, y - 1);\n          else cRef.fillText(i + \"🌴\", x - 1, y - 1);\n        }\n        x1 += dx;\n        y1 += dy;\n      }, t * speed);\n    }\n  };\n\n  //Makes line from p1 to p2\n  const createLine = (p1, p2, color, xi = 0, yi = 0) => {\n    let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n    let dist = JUMP;\n    let dy = Math.sin(angle) * dist;\n    let dx = Math.cos(angle) * dist;\n    let x1 = p1.x;\n    let y1 = p1.y;\n    let x2 = p2.x;\n    let y2 = p2.y;\n    let distt = Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));\n    let cRef = canvasRef.current.getContext(\"2d\");\n    let mx = 0;\n    for (let i = 0; i < pointsPhermone.length; i++) {\n      for (let j = 0; j < pointsPhermone[i].length; j++)\n        mx = Math.max(mx, pointsPhermone[i][j]);\n    }\n    if (color === 1) color = null;\n    let opacity = PHERMONE_UNIT;\n    // if (color === \"black\") {\n    //   color = null;\n    //   opacity = parseFloat(pointsPhermone[xi][yi] * 0.5);\n    //   console.log(xi, yi, pointsPhermone[xi][yi], opacity);\n    // }\n    //cRef.fillStyle = \"rgb(0, 191, 255,\" + opacity + \")\";\n    cRef.fillStyle = COLOR;\n    cRef.globalAlpha = 0.1;\n\n    if (color === \"red\" || color === \"green\") {\n      cRef.globalAlpha = 1;\n      cRef.fillStyle = color;\n    }\n\n    for (let t = 0; t <= distt / dist; t++) {\n      // eslint-disable-next-line no-loop-func\n      setTimeout(() => {\n        // if (color === \"blue\") {\n        //   opacity *= 0.5;\n        //   cRef.fillStyle = \"rgb(0, 191, 255,\" + opacity + \")\";\n        //   cRef.clearRect(x1, y1, 3, 3);\n        // }\n        if (color === \"red\" || color === \"green\") cRef.fillRect(x1, y1, 6, 6);\n        else cRef.fillRect(x1, y1, 3, 3);\n        x1 += dx;\n        y1 += dy;\n      }, t * speed);\n    }\n  };\n\n  //clear line from p1 to p2\n  const clearLine = (p1, p2) => {\n    let angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);\n    let dist = JUMP;\n    let dy = Math.sin(angle) * dist;\n    let dx = Math.cos(angle) * dist;\n    let x1 = p1.x;\n    let y1 = p1.y;\n    let x2 = p2.x;\n    let y2 = p2.y;\n    let distt = Math.sqrt(Math.pow(y2 - y1, 2) + Math.pow(x2 - x1, 2));\n    let cRef = canvasRef.current.getContext(\"2d\");\n    for (let t = 0; t <= distt / dist; t++) {\n      // eslint-disable-next-line no-loop-func\n      setTimeout(() => {\n        cRef.clearRect(x1, y1, 3, 3);\n        x1 += dx;\n        y1 += dy;\n      }, t * speed);\n    }\n  };\n\n  //choose next city using ACO\n  const heuristic = (p, cities, antindex) => {\n    let chooseFromcities = new Map();\n    let new_city = 0;\n    for (let i = 0; i < cities.length; i++) {\n      if (i === p || antFlag[i][antindex] === true) continue;\n      chooseFromcities.set(new_city++, i);\n    }\n\n    ////console.log(chooseFromcities);\n\n    let probability = [];\n    let totalProb = 0;\n    for (let [key, city] of chooseFromcities) {\n      ////console.log(pointsPhermone[p][city]);\n      let firstFactor = Math.pow(parseFloat(pointsPhermone[p][city]), ALPHA);\n      let secondFactor = Math.pow(\n        parseFloat(1 / distBtwPoints(cities, p, city)),\n        BETA\n      );\n      //console.log(\"factors\", firstFactor, secondFactor);\n      let val = parseFloat(firstFactor * secondFactor);\n      //console.log(\"probable value\", val);\n      probability.push(val);\n      totalProb = parseFloat(totalProb + probability[key]);\n    }\n\n    if (probability.length === 0) return p;\n    //console.log(\"total prob\", totalProb);\n    if (totalProb !== 0) {\n      for (let i = 0; i < probability.length; i++) {\n        probability[i] = parseFloat(probability[i] / totalProb);\n      }\n    } else {\n      let city = chooseFromcities.get(\n        parseInt(Math.random() * (probability.length - 1))\n      );\n      //console.log(city);\n      return city;\n    }\n    //console.log(probability);\n    let cumuProb = [];\n    cumuProb.push(probability[0]);\n    for (let i = 1; i < probability.length; i++) {\n      cumuProb.push(probability[i] + cumuProb[i - 1]);\n    }\n\n    //console.log(cumuProb);\n\n    let approxRandomSelectedCity =\n      Math.random() * cumuProb[probability.length - 1];\n\n    for (let i = 0; i < cumuProb.length; i++) {\n      if (approxRandomSelectedCity < cumuProb[i]) {\n        //console.log(p, chooseFromcities.get(i), approxRandomSelectedCity);\n        return chooseFromcities.get(i);\n      }\n    }\n    //console.log(\n    //  p,\n    //  chooseFromcities.get(probability.length - 1),\n    //  approxRandomSelectedCity\n    //);\n    return chooseFromcities.get(probability.length - 1);\n  };\n\n  const startACO = (\n    p,\n    t,\n    cities,\n    antindex,\n    color,\n    cityArr,\n    distanceCovered\n  ) => {\n    let next = heuristic(p, cities, antindex);\n    while (next !== p) {\n      // eslint-disable-next-line no-loop-func\n      console.log(next);\n      cityArr.push(next);\n      distanceCovered += distBtwPoints(cities, p, next);\n      let temp = [...antFlag];\n      temp[p][antindex] = true;\n      setAntFlag(temp);\n      let phermone2D = [...pointsPhermone];\n      phermone2D[p][next] += PHERMONE_UNIT;\n      phermone2D[next][p] += PHERMONE_UNIT;\n      setPointsPhermone(phermone2D);\n      // eslint-disable-next-line no-loop-func\n      //setTimeout(() => {\n      //createLine(cities[p], cities[next], color);\n      //}, t);\n      t += distBtwPoints(cities, p, next) * speed;\n      p = next;\n      next = heuristic(p, cities, antindex);\n    }\n\n    console.log(\"arr\", cityArr);\n    testPath(1, cityArr);\n\n    cityArr.push(antindex % points.length);\n    distanceCovered += distBtwPoints(cities, p, antindex % points.length);\n    let temp_antDescrip = antDescrip;\n    let info = [];\n    info.push(antindex);\n    info.push(cityArr);\n    info.push(distanceCovered);\n    info.push(t);\n    temp_antDescrip.set(antindex, info);\n    setAntDescrip(temp_antDescrip);\n    let phermone2D = [...pointsPhermone];\n    phermone2D[p][antindex % points.length] += PHERMONE_UNIT;\n    phermone2D[antindex % points.length][p] += PHERMONE_UNIT;\n    setPointsPhermone(phermone2D);\n\n    //setTimeout(() => {\n    //createLine(cities[p], cities[antindex % points.length], color);\n    //}, t);\n  };\n\n  //Starts actual Ant Colony Optimisation\n  // const startACO2 = (\n  //   p,\n  //   t,\n  //   cities,\n  //   antindex,\n  //   color,\n  //   cityArr,\n  //   distanceCovered\n  // ) => {\n  //   ////console.log(antindex, t);\n  //   let done = false;\n  //   let next = p;\n  //   next = heuristic(p, cities, antindex);\n  //   //////console.log(\"City to\", next);\n  //   if (next !== p) {\n  //     cityArr.push(next);\n  //     distanceCovered += distBtwPoints(cities, p, next);\n  //   }\n  //   if (next === p) {\n  //     done = true;\n  //     distanceCovered += distBtwPoints(cities, p, antindex % points.length);\n  //     let temp_antDescrip = antDescrip;\n  //     let info = [];\n  //     info.push(antindex);\n  //     info.push(cityArr);\n  //     info.push(distanceCovered);\n  //     info.push(t);\n  //     temp_antDescrip.set(antindex, info);\n  //     setAntDescrip(temp_antDescrip);\n  //   }\n  //   let temp = [...antFlag];\n  //   temp[p][antindex] = true;\n  //   setAntFlag(temp);\n  //   if (done === true) {\n  //     let phermone2D = [...pointsPhermone];\n  //     phermone2D[p][antindex % points.length] += PHERMONE_UNIT;\n  //     phermone2D[antindex % points.length][p] += PHERMONE_UNIT;\n  //     setPointsPhermone(phermone2D);\n  //     createLine(cities[p], cities[antindex % points.length], color);\n  //     let timer =\n  //       t * speed + distBtwPoints(cities, p, antindex % points.length) * speed;\n  //     setTimeout(() => {\n  //       return;\n  //     }, timer);\n  //   } else {\n  //     let phermone2D = [...pointsPhermone];\n  //     phermone2D[p][next] += PHERMONE_UNIT;\n  //     phermone2D[next][p] += PHERMONE_UNIT;\n  //     setPointsPhermone(phermone2D);\n  //     createLine(cities[p], cities[next], color);\n  //     let timer = t * speed + distBtwPoints(cities, p, next) * speed;\n  //     ////console.log(p, next, distBtwPoints(cities, p, next));\n  //     setTimeout(() => {\n  //       startACO(\n  //         next,\n  //         timer,\n  //         cities,\n  //         antindex,\n  //         color,\n  //         cityArr,\n  //         distanceCovered\n  //       );\n  //     }, timer);\n  //   }\n  // };\n\n  const ACO = () => {\n    if (points.length === 0) return;\n\n    let temp2 = [...antFlag];\n    for (let i = 0; i < temp2.length; i++) {\n      for (let j = 0; j < temp2[i].length; j++) {\n        temp2[i][j] = false;\n      }\n    }\n    setAntFlag(temp2);\n\n    let temp = [...pointsPhermone];\n    for (let i = 0; i < pointsPhermone.length; i++) {\n      for (let j = 0; j < pointsPhermone.length; j++) {\n        temp[i][j] *= EVAPORAION_RATE;\n      }\n    }\n\n    let highestTimeoutId = setTimeout(\";\"); // to stop all setTimeouts!\n    for (let i = 0; i < highestTimeoutId; i++) {\n      clearTimeout(i);\n    }\n\n    setPointsPhermone(temp);\n    setIte(ite + 1);\n\n    setShow(false);\n\n    setCOLOR(\"#\" + Math.floor(Math.random() * 16777215).toString(16));\n    for (let i = 0; i < ants; i++) {\n      let temp = [];\n      temp.push(i % points.length);\n      startACO(i % points.length, 0, points, i, null, temp, 0); //start_city,initalTimer,cities[],index,NEXT_CITY_arr[],distance\n    }\n  };\n\n  return (\n    <div className=\"App\">\n      <div style={{ margin: \"10px\", fontSize: \"16px\", color: \"blue\" }}>\n        Travelling Salesman Problem using - Ant Colony Optimisation (ACO)\n      </div>\n      <div style={{ margin: \"10px\", fontSize: \"12px\" }}>\n        10 Ants explore around with each click of \"Start ACO...\" and find the\n        better path in every iteration!!\n      </div>\n      <div style={{ margin: \"10px\", fontSize: \"12px\", fontWeight: \"bold\" }}>\n        This NP Hard Problem uses heuristic approach to find better approximate\n        solution\n      </div>\n      <div style={{ margin: \"10px\", fontSize: \"12px\" }}>\n        Probability for an ant to select a city = ((phermone amount deposited on\n        a edge)^ALPHA*(distance of that edge)^BETA)/Sum of the Numerator factor\n        for all edges(in path of ant)\n      </div>\n      <div\n        style={\n          window.innerWidth > 768\n            ? {\n                display: \"flex\",\n                justifyContent: \"center\",\n                margin: \"10px\",\n                fontSize: \"10px\",\n              }\n            : {\n                justifyContent: \"center\",\n                margin: \"10px\",\n                fontSize: \"10px\",\n              }\n        }\n      >\n        <button style={{ margin: \"10px\" }} onClick={() => ACO()}>\n          Start ACO {ite + 1} Iteration\n        </button>\n        {/* <button onClick={() => evap()}>Evaporate...</button>\n        <button\n          onClick={() => {\n            setPoints([]);\n            canvasRef.current.getContext(\"2d\").clearRect(0, 0, 1800, 950);\n          }}\n        >\n          Clear Canvas\n        </button> */}\n        {/* <div>\n          Rate(1-60 milliseconds):\n          <input\n            type=\"number\"\n            value={speed}\n            onChange={(e) => {\n              setSpeed(e.target.value);\n            }}\n            min=\"1\"\n            max=\"50\"\n          />\n        </div> */}\n        {/* <div>\n          No. of Ants\n          <input\n            type=\"number\"\n            value={ants}\n            onChange={(e) => {\n              setAnts(e.target.value);\n            }}\n          />\n        </div> */}\n        <div style={{ margin: \"10px\" }}>\n          ALPHA\n          <input\n            type=\"number\"\n            value={ALPHA}\n            onChange={(e) => {\n              setALPHA(e.target.value);\n            }}\n            min=\"1\"\n            max=\"50\"\n          />\n        </div>\n        <div style={{ margin: \"10px\" }}>\n          BETA\n          <input\n            type=\"number\"\n            value={BETA}\n            onChange={(e) => {\n              setBETA(e.target.value);\n            }}\n            min=\"1\"\n            max=\"50\"\n          />\n        </div>\n        <div style={{ margin: \"10px\" }}>\n          Evaporation rate of phermone(0-100)(in %)\n          <input\n            type=\"number\"\n            value={EVAPORAION_RATE * 100}\n            onChange={(e) => {\n              setEVAPORAION_RATE(e.target.value / 100);\n            }}\n            min=\"1\"\n            max=\"100\"\n          />\n        </div>\n        <button style={{ margin: \"10px\" }} onClick={() => testPath(5, points)}>\n          Make Lines\n        </button>\n        {/* <button onClick={() => testPath(2, points)}>Clear Lines</button>\n        <button onClick={() => testPath(0, points)}>Move point</button> */}\n        <button style={{ margin: \"10px\" }} onClick={() => plotMin()}>\n          Show min\n        </button>\n        <button style={{ margin: \"10px\" }} onClick={() => plotMax()}>\n          Show max\n        </button>\n      </div>\n      <div>\n        <canvas\n          ref={canvasRef}\n          width={window.innerWidth}\n          height={window.innerHeight / 2}\n          style={{ border: \"2px solid black\", backgroundColor: \"black\" }}\n          onClick={(e) => plotCityandInit(e)}\n        ></canvas>\n        <div>\n          Iteration: {ite}\n          {[...antDescrip].map((ant) => {\n            return (\n              <div>\n                <div>\n                  <span style={{ margin: \"10px\", fontSize: \"12px\" }}>\n                    🐜 {ant[1][0] + 1} : Tour: |\n                  </span>\n                  {ant[1][1].map((c) => (\n                    <span style={{ margin: \"10px\", fontSize: \"12px\" }}>\n                      {c}\n                    </span>\n                  ))}\n                  {/* <span>Time: {ant[1][3]} </span> */}\n                  <span style={{ margin: \"10px\", fontSize: \"12px\" }}>\n                    | distance covered: {ant[1][2]} units\n                  </span>\n                </div>\n              </div>\n            );\n          })}\n        </div>\n        <div style={{ margin: \"10px\", fontSize: \"12px\", color: \"red\" }}>\n          * Each iteration is shown by different color.\n        </div>\n        <div style={{ margin: \"10px\", fontSize: \"12px\", color: \"green\" }}>\n          * Once all the tour distances covered are equal, we can't get a more\n          better solution\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}